from typing import Any, Callable, Dict, NamedTuple, Optional, Tuple

import chex
from acme import specs
from acme.jax.networks import Action, Observation
from dm_env import TimeStep
from jax import numpy as jnp
from typing_extensions import Protocol

ArrayTree = Any
AgentState = ArrayTree
EnvironmentState = ArrayTree
DataGeneratorState = ArrayTree
BufferState = ArrayTree
Extras = ArrayTree
Batch = ArrayTree

Metrics = Dict[str, jnp.ndarray]
SelectAction = Callable[[AgentState, Observation, chex.PRNGKey], Tuple[Action, Extras]]
EvaluateFn = Callable[[AgentState, chex.PRNGKey], Metrics]


class DataGenerationInfo(NamedTuple):
    """Container for the information returned by data generation."""

    metrics: Metrics
    num_steps: jnp.int_
    num_episodes: jnp.int_


class EnvLoopState(NamedTuple):
    """State of the environment loop."""

    data_generator: DataGeneratorState
    buffer: BufferState
    agent: AgentState
    num_steps: jnp.int_
    num_episodes: jnp.int_
    num_iterations: jnp.int_


class GenerateDataFn(Protocol):
    """Callable specification for generation of experience.

    This typically contains multi-step, batched acting within a jittable environment."""

    def __call__(
        self, agent_state: AgentState, data_generator_state: DataGeneratorState
    ) -> Tuple[Batch, DataGeneratorState, DataGenerationInfo]:
        """
        The `generate_data` function.

        Args:
            agent_state: State of the agent itself (i.e. trainable parameters),
                used for generating actions.
            data_generator_state: State used during acting for management of the environment
                (e.g. keeping track of environment state).

        Returns:
            batch: Batch of data that will be passed to the agent update.
            data_generator_state: Updated data generator state.
            data_generation_info: Metrics from the data generation (information on acting).
        """


class DataGenerator(NamedTuple):
    """Container specifying pure functions for generation of experience data."""

    init: Callable[[chex.PRNGKey], DataGeneratorState]
    generate_data: GenerateDataFn


class Buffer(NamedTuple):
    """Buffer for managing the storage of experience generated by the actor,
    and the sampling of experience for updating the agent's parameters.

    The `sample` and `add` functions are both jittable."""

    add: Callable[[BufferState, Batch], BufferState]
    sample: Callable[[BufferState], Tuple[Batch, BufferState]]
    init: Callable[[chex.PRNGKey], BufferState]


class Agent(NamedTuple):
    """Pure functions defining the key components of the agent.

    Both the update function (which updates the agent's learnt parameters), and the
    select action function (which selects actions within the environment) are jittable.
    If it is desired to use multiple devices, then the update function should have the
    appropriately placed `jax.lax.pmean` to aggregate gradients across devices.
    """

    init: Callable[[chex.PRNGKey], AgentState]
    select_action: SelectAction
    update: Callable[[AgentState, Batch], Tuple[AgentState, Metrics]]
    # `select_action` will be used for evaluation if `select_action_eval` is None
    select_action_eval: Optional[SelectAction] = None


class OnlineAgent(NamedTuple):
    init: Callable[[chex.PRNGKey], AgentState]
    select_action: SelectAction
    update: Callable[[AgentState], Tuple[AgentState, Metrics]]
    select_action_eval: Optional[SelectAction] = None


class StepEnvironment(Protocol):
    """
    Environment transition definition.

    Note: The environment step function automatically resets the environment when an
    episode is completed. This allows for seamless, jitted n-step acting, however it requires some
    care when setting up the environment step function. Therefore, if you are creating an instance
    of this function, please refer to the details of the `__call__` function below (specifically the
    docstring of the returned objects), as well as the example environment in
    `ridl.functional.testing.toy_env`.

    """

    def __call__(
        self, state: EnvironmentState, action: Action
    ) -> Tuple[EnvironmentState, TimeStep, Metrics]:
        """
        Step the environment to the next state in the MDP with automatic resetting of
        terminated episodes.

        Args:
            state: State of the environment at the current timestep.
            action: Action taken at the current timestep.

        Returns:
            state: State of the environment at the next state (if the episode is
                still underway), or the state from a reset (if the episode terminates).
            timestep: Timestep containing information on the transition.
                If the episode terminates, then the fields of the timestep all correspond to the
                terminal timestep EXCEPT for the observation which corresponds to the observation
                from the auto-reset, as this is required for the next acting state, and the
                terminal observation is not needed.
            metrics: Relevant information for logging.
        """


class Environment(NamedTuple):
    """Minimal container which stores the key components of a jax environment, which has a jittable
    step function.

    Note:
        - This container is used within the data generator to generate experience, and is
          therefore not explicitly passed to the environment loop.
        - The `step` function is assumed to automatically reset the environment if an
          episode terminates, please refer to the `StepEnvironment` for details.
    """

    init: Callable[[chex.PRNGKey], Tuple[EnvironmentState, TimeStep]]
    step: StepEnvironment
    spec: specs.EnvironmentSpec
